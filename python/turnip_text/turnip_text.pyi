import abc
from typing import Iterator, List, Optional, Protocol, runtime_checkable

from turnip_text._native import Block, Inline

class UnescapedText(Inline):
    def __init__(self, text: str) -> None: ...
    @property
    def text(self) -> str: ...

class RawText(Inline):
    def __init__(self, text: str) -> None: ...
    @property
    def text(self) -> str: ...

# Note - Sentence is NOT an Inline. This means there's always a hierarchy of Paragraph -> many Sentences -> many Inlines.
# InlineScopes can be nested, Sentences cannot.
class Sentence:
    def __init__(self, list: Optional[List[Inline]] = None): ...
    def __len__(self) -> int: ...
    # Iterate over the inline blocks in the sentence
    def __iter__(self) -> Iterator: ...
    # Push an inline node into the sentence
    def push_inline(self, node: Inline): ...

class Paragraph(Block):
    def __init__(self, list: Optional[List[Sentence]] = None): ...
    def __len__(self) -> int: ...
    # Iterate over the sentences in the Paragraph
    def __iter__(self) -> Iterator[Sentence]: ...
    # Push a sentence into the Paragraph
    def push_sentence(self, s: Sentence): ...

class BlockScope(Block):
    def __init__(self, list: Optional[List[Block]] = None): ...
    def __len__(self) -> int: ...
    # Iterate over the blocks in the BlockScope
    def __iter__(self) -> Iterator[Block]: ...
    # Push a block into the BlockScope
    def push_block(self, b: Block): ...

class InlineScope(Inline):
    def __init__(self, list: Optional[List[Inline]] = None): ...
    def __len__(self) -> int: ...
    # Iterate over the inline items in the InlineScope
    def __iter__(self) -> Iterator[Inline]: ...
    # Push an inline item into the InlineScope
    def push_inline(self, b: Inline): ...
